<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>Sublist experiement</title>
		<meta name="description" content="">
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0">
		<meta name='HandheldFriendly' content='True'>
		<meta name='MobileOptimized' content='320'>
		<meta name='format-detection' content='telephone=no'>
	</head>
	<body>
		<div id="app"></div>
		<script>
			require.config({
				baseUrl: '/',
				paths : {
					'jquery' : 'bower_components/jquery/dist/jquery',
					'can': 'bower_components/canjs/amd/can'
				}
			});
		</script>
		<script src="/bower_components/requirejs/require.js"></script>
		<script>
			require(['can'], function(can){

        var newSublist=function(_name,addCB,rmCB,n){
          return (function(){
            var name = _name; // prevent renaming by making private
            var items = [];   // of use a wrapper on new can.Map  is need listeners
            return {  // only this stuff is public  zzz how use canjs to observe the list w/o allowing mods
              getName: function(){ return name; },
              add: function(o){ // TBD   when sublist is restricted to 1 item,  adding an item triggers removal of any existing item
                debugger;
                //if(o in items){ items.splice();
                // items.push(o);  // remove o since it will be put at the top of the stack // or maybe keep
                //if(n&& ) addCB(o);
              }
              remove: function(o){
                debugger;
                //if(o in items){ items.splice(); rmCB(o);
              }
              getItems: function(){ return items;  }
            };
          })();
        };

        var listWithSublists= can.List.extend({
          sublists:new can.map();
          addListToSublists:function(subList,n){
            if(!l1.sublists[subList.name] && subList.name!=undefined){ l1.sublists[subList.name]=subList; }
            this.delegate('remove',function(ev){
              debugger
            //  subList.remove(ev.target); // if item in sublist was removed from the list
            }
          },
          addToSublist:function(name,o){
            if(this.sublists[name] && this.indexOf(o)>0){
              this.sublists[name].add(o);  // can only add list items to sublist
            }
          },
          removeFromSublist:function(name,o){
            if(this.sublists[name] && this.indexOf(o)>0){
              this.sublists[name].remove(o);  // can only remove list items from sublist
            }
          }
            // what happens when reorder??
        });

        // SAMPLES:
        // var p1={name:'page1'};
        // var p2={name:'page2'};
        // var pages=[p1,p2];
        // var l1=new listWithSublists(pages);
        // l1.addListToSublists(
        //   newSubList('focusPage',function(){ dom.show(); }, function(){ dom.hide(); },1)
        //   ,1
        // );

        // TESTS
        //  lists  [] [A] [A,B,C]   // 0 1 many
        //  sublists    // 0 1 many

        //  add     // add to 0
        //   remove // remove from 1
        //    remove  // remove from 0
        //  add     // ibid add to 0
        //   add    // add to 1
        //    remove // remove from many
        //   add    // ibid add to 1
        //    add   // add to many
        //     remove   // remove from many - front
        //     remove   // remove from many - rear
        //      remove  // remove from one
        //       remove  // ibidremove from 0

        // when sublist has only 1 item
        // add B to sublist
        // remove B from list
        // check that B is removed from

        });
		</script>
	</body>
</html>